
**构造函数的初始值有时必不可少**

 - 有时候我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。（只看这几话不好理解，下面会举个例子），如果成员是**const**或者是**引用**的话，必须将其初始化。（否则会出现错误）类似的，当成员属于**某种类类型**且该类没有定义默认构造函数时，也必须将这个成员初始化。
 

```
 class ConstRef
 {
 public:
    ConstRef(int i);
 private:
    int i;
    const int ci;
    int &ri;
 };
 // 错误，ci和ri必须被初始化
 ConstRef::ConstRef(int ii)
 {// 赋值
    i= ii;  //正确
    ci = ii;  // 错误，不能给const赋值
    ri = i;  // ri没有被初始化
 }
 // 正确的初始化方式，这也显示了赋值和初始化的差异
 ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii) { }
```
**注意：** 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数的**初始值列表**为这些成员提供初值。