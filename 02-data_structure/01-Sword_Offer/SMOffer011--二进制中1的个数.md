```
题目描述

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

解题思路

位运算，将 n 与1做与运算，判断n的最低位是否为1。按常规思路，接着判断n的次低位，将n右移，再与1做与运算，但是这时候发现如果n为负数，则右移会有问题，所以这里将1左移，再与n与运算，则同样可以判断。

上述解法中循环的次数等于二进制的位数，下面有一种优化解法。

把一个整数减去1，都是把最右边的1变成0，如果右边还有0，则所有的0变成1，左边的位保持不变。则不难推出，把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。为求一个数的二进制中1的个数，可以把一个整数减1，再和原整数做与运算，将该整数最右边的1变成0，那么一个整数的二进制表示中有多少个1，则循环多少次。

```

```C++
class Solution {
public:
     int  NumberOf1(int n) {
         int cnt = 0;
         while(n){
             ++ cnt;
             n &= (n - 1);
         }
         return cnt;
     }
};


```

```python
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1(self, n):
        # write code here
        cnt = 0
        if n < 0:
            n = n & 0xffffffff
        while n:
            cnt += 1
            n = (n-1) & n
        return cnt


```
